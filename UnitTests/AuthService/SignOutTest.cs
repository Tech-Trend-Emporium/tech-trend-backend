using Application.Abstraction;
using Application.Abstractions;
using Application.Dtos.Auth;
using Application.Exceptions;
using Application.Services;
using Data.Entities;
using Domain.Entities;
using NSubstitute;
using Application.Services.Implementations;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace UnitTests.AuthServices
{
    // Code generated by AI
    public class SignOutTest
    {
        private readonly IUserRepository _userRepo = Substitute.For<IUserRepository>();
        private readonly ISessionRepository _sessionRepo = Substitute.For<ISessionRepository>();
        private readonly IRefreshTokenRepository _rtRepo = Substitute.For<IRefreshTokenRepository>();
        private readonly IUnitOfWork _uow = Substitute.For<IUnitOfWork>();
        private readonly Microsoft.AspNetCore.Identity.IPasswordHasher<User> _hasher = Substitute.For<Microsoft.AspNetCore.Identity.IPasswordHasher<User>>();
        private readonly ITokenService _tokens = Substitute.For<ITokenService>();
        private readonly AuthService _sut;

        public SignOutTest()
        {
            _sut = new AuthService(_userRepo, _sessionRepo, _rtRepo, _uow, _hasher, _tokens);
        }

        [Fact]
        public async Task SignOut_AllSessions_ShouldDeactivateAllAndRevokeAllTokens()
        {
            var ct = CancellationToken.None;
            int currentUserId = 5;
            var s1 = new Session { Id = 1, UserId = currentUserId, IsActive = true };
            var s2 = new Session { Id = 2, UserId = currentUserId, IsActive = true };

            _sessionRepo.GetActiveByUserAsync(currentUserId, ct).Returns(new List<Session> { s1, s2 });

            await _sut.SignOut(new SignOutRequest { AllSessions = true }, currentUserId, ct);

            Assert.False(s1.IsActive);
            Assert.False(s2.IsActive);
            await _rtRepo.Received(1).RevokeAllActiveByUserAsync(currentUserId, ct);
            await _uow.Received(1).SaveChangesAsync(ct);
        }

        [Fact]
        public async Task SignOut_SingleSession_ShouldRevokeGivenTokenAndDeactivateSession()
        {
            var ct = CancellationToken.None;
            int currentUserId = 7;
            var req = new SignOutRequest { AllSessions = false, RefreshToken = "rt-1" };

            var rt = TestHelper.NewRt(currentUserId, sessionId: 100, token: "rt-1", isActive: true);
            var session = new Session { Id = 100, UserId = currentUserId, IsActive = true };

            _rtRepo.GetByTokenAsync(req.RefreshToken, ct).Returns(rt);
            _sessionRepo.GetByIdAsync(ct, rt.SessionId).Returns(session);

            await _sut.SignOut(req, currentUserId, ct);

            Assert.NotNull(rt.RevokedAtUtc);
            Assert.False(session.IsActive);
            await _uow.Received(1).SaveChangesAsync(ct);
        }

        [Fact]
        public async Task SignOut_SingleSession_ShouldThrowBadRequest_WhenTokenMissing()
        {
            var ct = CancellationToken.None;
            var req = new SignOutRequest { AllSessions = false, RefreshToken = "   " };

            await Assert.ThrowsAsync<BadRequestException>(() => _sut.SignOut(req, 1, ct));
        }

        [Fact]
        public async Task SignOut_SingleSession_ShouldThrowNotFound_WhenTokenDoesNotBelongToCurrentUserOrNotExists()
        {
            var ct = CancellationToken.None;
            int currentUserId = 10;

            _rtRepo.GetByTokenAsync("nope", ct).Returns((RefreshToken?)null);
            await Assert.ThrowsAsync<NotFoundException>(() => _sut.SignOut(new SignOutRequest { AllSessions = false, RefreshToken = "nope" }, currentUserId, ct));

            var othersRt = TestHelper.NewRt(userId: 999, sessionId: 1, token: "alien", isActive: true);
            _rtRepo.GetByTokenAsync("alien", ct).Returns(othersRt);
            await Assert.ThrowsAsync<NotFoundException>(() => _sut.SignOut(new SignOutRequest { AllSessions = false, RefreshToken = "alien" }, currentUserId, ct));
        }
    }
}
