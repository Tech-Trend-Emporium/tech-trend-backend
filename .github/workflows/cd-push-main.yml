name: cd-push-main

on:
  push:
    branches: [main, dev]
  workflow_dispatch:
  
concurrency:
  group: cd-push-main
  cancel-in-progress: false

permissions:
  id-token: write   # OIDC to Azure
  contents: read

env:
  # --- Required repo VARIABLES (Settings > Variables) ---
  REGISTRY_SERVER: ${{ secrets.ACR_LOGIN_SERVER }}              # e.g. myregistry.azurecr.io
  REGISTRY_NAMESPACE: tech-trend-emporium                       # logical repo namespace (optional)
  ACR_REPO: tech-trend-emporium/api                             # ACR repo (no server)
  RESOURCE_GROUP: ${{ vars.RG }}                                # e.g. rg-trendtech-dev
  ACA_ENV_NAME: ${{ vars.ACA_ENV_NAME }}                        # Container Apps Environment name
  ACA_APP_NAME: ${{ vars.ACA_APP_NAME }}                        # Container App name (single app)
  HEALTH_ENDPOINT: ${{ vars.HEALTH_ENDPOINT }}                  # e.g. /healthz (defaults below if empty)
  HEALTH_TIMEOUT_SECONDS: "120"                                 # total wait time on green
  # --- Derived ---
  IMAGE_TAG: ${{ github.sha }}
  IMAGE_DIGEST_TAG: ${{ github.sha }}                           # keep the same; could be changed to digest if desired
  IMAGE_URI: ${{ env.REGISTRY_SERVER }}/${{ env.ACR_REPO }}:${{ env.IMAGE_TAG }}
  REVISION_SUFFIX: ${{ github.sha }}
  GREEN_LABEL: green
  BLUE_LABEL: blue

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout (for scripts or manifests if needed)
        uses: actions/checkout@v4

      # --- Login to Azure using OIDC (recommended) ---
      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      # If your Container App does NOT already have registry credentials configured,
      # make sure the ACA’s managed identity has AcrPull on your ACR, OR set credentials on the app.
      # See NOTE after the YAML.

      - name: Azure CLI - Ensure multiple revisions + deploy green @0%
        uses: azure/cli@v2
        with:
          azcliversion: 2.62.0
          inlineScript: |
            set -e

            APP="${{ env.ACA_APP_NAME }}"
            RG="${{ env.RESOURCE_GROUP }}"
            ENV_NAME="${{ env.ACA_ENV_NAME }}"
            IMG="${{ env.IMAGE_URI }}"
            REV="${{ env.REVISION_SUFFIX }}"
            BLUE="${{ env.BLUE_LABEL }}"
            GREEN="${{ env.GREEN_LABEL }}"

            echo "Using image: $IMG"

            # 1) Make sure revision mode is multiple (required for traffic splitting)
            az containerapp revision set-mode \
              --name "$APP" \
              --resource-group "$RG" \
              --mode multiple

            # 2) Update the app to create a NEW revision (green) with the new image and a deterministic suffix
            #    (If the app doesn't exist yet, you can create it once with --revisions-mode multiple)
            az containerapp update \
              --name "$APP" \
              --resource-group "$RG" \
              --image "$IMG" \
              --revision-suffix "$REV"

            # 3) Label the two revisions (idempotent):
            #    - label the new one as "green"
            #    - ensure the current prod has "blue"
            # Determine current latest revision (the one we just created)
            LATEST_REV=$(az containerapp revision list -g "$RG" -n "$APP" --query "[?properties.trafficWeight==\`0\` && properties.active==\`true\`].name | [0]" -o tsv)
            if [ -z "$LATEST_REV" ]; then
              # Fallback: pick latest by creation time
              LATEST_REV=$(az containerapp revision list -g "$RG" -n "$APP" --query "sort_by([?properties.active==\`true\`], &properties.createdTimeUtc)[-1].name" -o tsv)
            fi
            echo "Latest (new) revision: $LATEST_REV"

            # Add labels (best-effort; ignore if already labeled)
            az containerapp revision label add -g "$RG" -n "$APP" --label "$GREEN" --revision "$LATEST_REV" || true

            # Find the current prod revision receiving traffic (weight > 0)
            PROD_REV=$(az containerapp revision list -g "$RG" -n "$APP" --query "[?properties.trafficWeight> \`0\` && properties.active==\`true\`].name | [0]" -o tsv)
            if [ -n "$PROD_REV" ]; then
              az containerapp revision label add -g "$RG" -n "$APP" --label "$BLUE" --revision "$PROD_REV" || true
              echo "Blue (prod) revision: $PROD_REV"
            else
              echo "No existing prod traffic found; this may be first deploy."
            fi

            # 4) Route 0% prod traffic to green (by labels) and keep blue at 100
            #    If this is first-ever deploy, green will get 100 and blue will be 0 automatically based on what's labeled/exists.
            if [ -n "$PROD_REV" ]; then
              az containerapp ingress traffic set \
                --name "$APP" \
                --resource-group "$RG" \
                --label-weight "$BLUE=100" "$GREEN=0"
            fi

            # 5) Get the green label FQDN for health checks
            APP_DOMAIN=$(az containerapp env show -g "$RG" -n "$ENV_NAME" --query properties.defaultDomain -o tsv | tr -d '\r\n')
            GREEN_FQDN="https://${APP}---${GREEN}.${APP_DOMAIN}"
            echo "Green URL: $GREEN_FQDN"

            echo "GREEN_FQDN=$GREEN_FQDN" >> $GITHUB_ENV

      - name: Health check green
        shell: bash
        run: |
          set -e
          GREEN_URL="${GREEN_FQDN}"
          PATH_TO_CHECK="${{ env.HEALTH_ENDPOINT }}"
          [ -z "$PATH_TO_CHECK" ] && PATH_TO_CHECK="/healthz"

          echo "Probing ${GREEN_URL}${PATH_TO_CHECK} for up to ${{ env.HEALTH_TIMEOUT_SECONDS }} seconds..."

          end=$((SECONDS + ${{ env.HEALTH_TIMEOUT_SECONDS }}))
          passed=0
          while [ $SECONDS -lt $end ]; do
            code=$(curl -sk -o /dev/null -w "%{http_code}" "${GREEN_URL}${PATH_TO_CHECK}")
            echo "HTTP $code"
            if [ "$code" -ge 200 ] && [ "$code" -lt 500 ]; then
              passed=1
              break
            fi
            sleep 5
          done

          if [ $passed -ne 1 ]; then
            echo "Green health check FAILED"
            exit 1
          fi

      - name: Shift traffic to green (100%)
        if: ${{ success() }}
        uses: azure/cli@v2
        with:
          azcliversion: 2.62.0
          inlineScript: |
            set -e
            APP="${{ env.ACA_APP_NAME }}"
            RG="${{ env.RESOURCE_GROUP }}"
            BLUE="${{ env.BLUE_LABEL }}"
            GREEN="${{ env.GREEN_LABEL }}"

            # 6) Send all prod traffic to green by label
            az containerapp ingress traffic set \
              --name "$APP" \
              --resource-group "$RG" \
              --label-weight "$BLUE=0" "$GREEN=100"

            # (Optional) Deactivate previous blue revision to keep only one active old revision
            # Find any active, non-green revision(s) that have traffic=0 and deactivate
            OLD_REVS=$(az containerapp revision list -g "$RG" -n "$APP" \
              --query "[?properties.active==\`true\` && !(labels && to_string(labels.${GREEN}))].name" -o tsv)
            for r in $OLD_REVS; do
              echo "Deactivating old revision: $r"
              az containerapp revision deactivate -g "$RG" -n "$APP" --revision "$r" || true
            done

      - name: Rollback hint on failure
        if: ${{ failure() }}
        run: |
          echo "Deployment failed: kept BLUE live. Investigate green revision logs."
          echo "To rollback traffic manually (if needed):" >> $GITHUB_STEP_SUMMARY
          echo "az containerapp ingress traffic set -n ${{ env.ACA_APP_NAME }} -g ${{ env.RESOURCE_GROUP }} --label-weight ${{ env.BLUE_LABEL }}=100 ${{ env.GREEN_LABEL }}=0" >> $GITHUB_STEP_SUMMARY

      - name: Summary
        if: always()
        run: |
          echo "Image: ${{ env.IMAGE_URI }}" >> $GITHUB_STEP_SUMMARY
          echo "Green URL: ${{ env.GREEN_FQDN }}" >> $GITHUB_STEP_SUMMARY
