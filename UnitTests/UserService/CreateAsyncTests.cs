using Application.Abstraction;
using Application.Abstractions;
using Application.Exceptions;
using Data.Entities;
using General.Dto.User;
using General.Mappers;
using Microsoft.AspNetCore.Identity;
using NSubstitute;
using Application.Services.Implementations;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace UnitTests.UserServices
{
    // Code generated by AI
    public class CreateAsyncTests
    {
        private readonly IUserRepository _userRepository;
        private readonly IUnitOfWork _unitOfWork;
        private readonly IPasswordHasher<User> _passwordHasher;
        private readonly Application.Services.Implementations.UserService _service;

        public CreateAsyncTests()
        {
            _userRepository = Substitute.For<IUserRepository>();
            _unitOfWork = Substitute.For<IUnitOfWork>();
            _passwordHasher = Substitute.For<IPasswordHasher<User>>();

            _service = new Application.Services.Implementations.UserService(_userRepository, _unitOfWork, _passwordHasher);
        }

        [Fact]
        public async Task CreateAsync_ShouldCreateUser_WhenValidDto()
        {
            // Arrange
            var ct = CancellationToken.None;
            var dto = new CreateUserRequest
            {
                Username = "TestUser",
                Email = "test@example.com",
                Password = "root12345", 
                Role = Domain.Enums.Role.SHOPPER,
            };

            _userRepository.ExistsAsync(Arg.Any<System.Linq.Expressions.Expression<Func<User, bool>>>(), ct)
                .Returns(false,false);

            _passwordHasher.HashPassword(Arg.Any<User>(), dto.Password).Returns("hashed" + dto.Password);

            var userEntity = new User
            {
                Id = 1,
                Username = dto.Username,
                Email = dto.Email,
                PasswordHash = "hashed" + dto.Password,
                Role = Domain.Enums.Role.SHOPPER
            };

            var expectedResponse = UserMapper.ToResponse(userEntity);            

            // Act
            var result = await _service.CreateAsync(dto, CancellationToken.None);

            // Assert
            Assert.NotNull(result);
            Assert.Equal(expectedResponse.Username, result.Username);
            Assert.Equal(expectedResponse.Email, result.Email);           

            await _unitOfWork.Received(1).SaveChangesAsync(ct);
            
        }

        [Fact]
        public async Task CreateAsync_ShouldThrowArgumentNull_WhenDtoIsNull()
        {
            //Arange
            var ct = CancellationToken.None;

            // Act & assert
            await Assert.ThrowsAsync<ArgumentNullException>(() => _service.CreateAsync((CreateUserRequest?)null, ct));
        }

        [Fact]
        public async Task CreateAsync_ShouldThrowConflict_WhenUsernameExists()
        {
            // Arrange
            var ct = CancellationToken.None;
            var dto = new CreateUserRequest
            {
                Username = "TestUser",
                Email = "test@example.com",
                Password = "root12345"
            };


            _userRepository.ExistsAsync(Arg.Any<System.Linq.Expressions.Expression<Func<User, bool>>>(), ct)
                .Returns(true, false);
            //Act & Assert
            await Assert.ThrowsAsync<ConflictException>(() => _service.CreateAsync(dto, ct));
        }

            

        [Fact]
        public async Task CreateAsync_ShouldThrowConflict_WhenEmailExists()
        {
            // Arrange
            var ct = CancellationToken.None;
            var dto = new CreateUserRequest
            {
                Username = "TestUser",
                Email = "test@example.com",
                Password = "12345"
            };

            // First call (username check) = false, second (email check) = true
            _userRepository.ExistsAsync(Arg.Any<System.Linq.Expressions.Expression<Func<User, bool>>>(),ct)
                .Returns(Task.FromResult(false), Task.FromResult(true));

            // Act & Assert
            await Assert.ThrowsAsync<ConflictException>(() => _service.CreateAsync(dto, ct));
        }
    }
}
